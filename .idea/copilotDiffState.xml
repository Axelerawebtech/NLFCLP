<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/pages/api/interview/submit-tracking.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pages/api/interview/submit-tracking.js" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="import dbConnect from '../../../lib/mongodb';&#10;&#10;// Interview tracking schema (we'll store this in a simple collection)&#10;const InterviewTracking = {&#10;  async create(data) {&#10;    const { db } = await dbConnect();&#10;    const collection = db.collection('interview_tracking');&#10;    return await collection.insertOne({&#10;      ...data,&#10;      createdAt: new Date(),&#10;      updatedAt: new Date()&#10;    });&#10;  },&#10;&#10;  async findByUserId(userId) {&#10;    const { db } = await dbConnect();&#10;    const collection = db.collection('interview_tracking');&#10;    return await collection.find({ userId }).sort({ createdAt: -1 }).toArray();&#10;  }&#10;};&#10;&#10;export default async function handler(req, res) {&#10;  if (req.method !== 'POST') {&#10;    return res.status(405).json({ message: 'Method not allowed' });&#10;  }&#10;&#10;  try {&#10;    const {&#10;      userId,&#10;      startTime,&#10;      endTime,&#10;      totalDuration,&#10;      focusStats,&#10;      fullscreenStats,&#10;      interviewType = 'general'&#10;    } = req.body;&#10;&#10;    // Validate required fields&#10;    if (!startTime || !endTime) {&#10;      return res.status(400).json({ &#10;        success: false, &#10;        message: 'Start time and end time are required' &#10;      });&#10;    }&#10;&#10;    // Calculate additional metrics&#10;    const totalOutOfFocusPercentage = totalDuration &gt; 0 &#10;      ? ((focusStats.totalOutOfFocusDuration / totalDuration) * 100).toFixed(2)&#10;      : 0;&#10;&#10;    const averageOutOfFocusDuration = focusStats.outOfFocusCount &gt; 0&#10;      ? (focusStats.totalOutOfFocusDuration / focusStats.outOfFocusCount)&#10;      : 0;&#10;&#10;    // Prepare tracking data&#10;    const trackingData = {&#10;      userId: userId || 'anonymous',&#10;      interviewType,&#10;      session: {&#10;        startTime: new Date(startTime),&#10;        endTime: new Date(endTime),&#10;        totalDuration,&#10;        totalDurationFormatted: formatDuration(totalDuration)&#10;      },&#10;      focusTracking: {&#10;        ...focusStats,&#10;        totalOutOfFocusPercentage: parseFloat(totalOutOfFocusPercentage),&#10;        averageOutOfFocusDuration,&#10;        focusScore: calculateFocusScore(focusStats, totalDuration)&#10;      },&#10;      fullscreenTracking: {&#10;        ...fullscreenStats,&#10;        fullscreenComplianceScore: calculateFullscreenScore(fullscreenStats)&#10;      },&#10;      overallScore: calculateOverallScore(focusStats, fullscreenStats, totalDuration),&#10;      metadata: {&#10;        userAgent: req.headers['user-agent'],&#10;        ip: req.headers['x-forwarded-for'] || req.connection.remoteAddress,&#10;        timestamp: new Date()&#10;      }&#10;    };&#10;&#10;    // Save to database&#10;    const result = await InterviewTracking.create(trackingData);&#10;&#10;    console.log('Interview tracking data saved:', {&#10;      id: result.insertedId,&#10;      userId: trackingData.userId,&#10;      focusScore: trackingData.focusTracking.focusScore,&#10;      overallScore: trackingData.overallScore&#10;    });&#10;&#10;    res.status(200).json({&#10;      success: true,&#10;      message: 'Interview tracking data saved successfully',&#10;      data: {&#10;        trackingId: result.insertedId,&#10;        focusScore: trackingData.focusTracking.focusScore,&#10;        fullscreenScore: trackingData.fullscreenTracking.fullscreenComplianceScore,&#10;        overallScore: trackingData.overallScore,&#10;        summary: {&#10;          totalDuration: formatDuration(totalDuration),&#10;          outOfFocusCount: focusStats.outOfFocusCount,&#10;          totalOutOfFocusDuration: formatDuration(focusStats.totalOutOfFocusDuration),&#10;          fullscreenExitCount: fullscreenStats.fullscreenExitCount,&#10;          outOfFocusPercentage: `${totalOutOfFocusPercentage}%`&#10;        }&#10;      }&#10;    });&#10;&#10;  } catch (error) {&#10;    console.error('Error saving interview tracking data:', error);&#10;    res.status(500).json({&#10;      success: false,&#10;      message: 'Failed to save interview tracking data',&#10;      error: error.message&#10;    });&#10;  }&#10;}&#10;&#10;// Helper functions&#10;function formatDuration(milliseconds) {&#10;  const totalSeconds = Math.floor(milliseconds / 1000);&#10;  const hours = Math.floor(totalSeconds / 3600);&#10;  const minutes = Math.floor((totalSeconds % 3600) / 60);&#10;  const seconds = totalSeconds % 60;&#10;  &#10;  if (hours &gt; 0) {&#10;    return `${hours}h ${minutes}m ${seconds}s`;&#10;  } else if (minutes &gt; 0) {&#10;    return `${minutes}m ${seconds}s`;&#10;  } else {&#10;    return `${seconds}s`;&#10;  }&#10;}&#10;&#10;function calculateFocusScore(focusStats, totalDuration) {&#10;  if (totalDuration === 0) return 100;&#10;  &#10;  const outOfFocusPercentage = (focusStats.totalOutOfFocusDuration / totalDuration) * 100;&#10;  const focusScore = Math.max(0, 100 - outOfFocusPercentage);&#10;  &#10;  // Additional penalties for frequent focus losses&#10;  const frequencyPenalty = Math.min(20, focusStats.outOfFocusCount * 2);&#10;  &#10;  return Math.max(0, focusScore - frequencyPenalty);&#10;}&#10;&#10;function calculateFullscreenScore(fullscreenStats) {&#10;  // Start with 100 and deduct points for each exit&#10;  const baseScore = 100;&#10;  const penaltyPerExit = 10;&#10;  const score = Math.max(0, baseScore - (fullscreenStats.fullscreenExitCount * penaltyPerExit));&#10;  &#10;  return score;&#10;}&#10;&#10;function calculateOverallScore(focusStats, fullscreenStats, totalDuration) {&#10;  const focusScore = calculateFocusScore(focusStats, totalDuration);&#10;  const fullscreenScore = calculateFullscreenScore(fullscreenStats);&#10;  &#10;  // Weighted average: 70% focus, 30% fullscreen&#10;  const overallScore = (focusScore * 0.7) + (fullscreenScore * 0.3);&#10;  &#10;  return Math.round(overallScore);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>